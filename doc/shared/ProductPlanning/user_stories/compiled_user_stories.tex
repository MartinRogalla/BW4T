\documentclass{article}
\usepackage[utf8]{inputenc}
\title{User stories}
\date{10 May 2014}

\begin{document}

\maketitle
\section{Features}
\begin{description}
  \item[Story 1.1:] Configuration Files (Scenario GUI)\\
  As a user\\
  I want to have a scenario GUI\\
  So that I can easily make custom configurations that are read by GOAL to create maps

  \begin{description}
    \item[Scenario 1.1.1:] Configuration changing\\
    Given the user has started the program\\
    When the user has launched the GUI\\
    Then the user can change the settings from a standard map to create a map with an entirely new set of configurations
    
    \item[Scenario 1.1.2:] Room count\\
    Given the user has changed the room count\\
    When the user presses the create map button\\
    Then the configuration file created contains that amount of rooms\\
    And the map shows that amount of rooms when loaded as environment
    
    \item[Scenario 1.1.3:] Bots\\
    Given the user has launched the scenario GUI\\
    And the user has specified how many bots\\
    When the user presses the create map button\\
    Then the system creates a configuration file containing the settings

    \item[Scenario 1.1.4:] Human Players\\
    Given the user has launched the scenario GUI\\
    And the user has specified which bot is human controlled\\
    When the user presses the create map button\\
    Then the system creates a configuration file containing the settings
    
    \item[Scenario 1.1.5:] Maps\\
    Given the user has launched the scenario GUI\\
    And the user has created the map they wanted\\
    When the user presses the create map button\\
    Then the system creates a configuration file corresponding with the map
  \end{description}
  \item[Story 1.2:] Human Player GUI\\
  As a user \\
  I want to control the bot via the human player GUI\\
  So that I can tell the bot what to do

  \begin{description}
    \item[Scenario 1.2.1:] GUI starting\\
    Given a map with at least one human player has been created\\
    When the map is used in a GOAL multi agent system\\
    Then there should be a human player GUI launched for every human player given in the map
    
    \item[Scenario 1.2.2:] Control\\
    Given the human player GUI has started\\
    When the user clicks a command given in the list of possible commands\\
    Then the bot executes that command and the GUI shows this as feedback

    \item[Scenario 1.2.3:] Message sending\\
    Given the human player GUI has started\\
    When the user makes a message and sends it\\
    Then the GUI should show this message as being sent
    
    \item[Scenario 1.2.4:] Message receiving\\
    Given the human player GUI has started\\
    When the user receives a message made by another human player GUI\\
    Then the GUI should show this message as being received

    \item[Scenario 1.2.5:] Visual Feedback\\
    Given the human player GUI has started\\
    When an event has occurred that limits or extends the bots commands\\
    Then the list of possible commands in the GUI should be updated
  \end{description}
  \item[Story 1.3:] E-Partner\\
  As a user\\
  I want to be able to use my E-Partner\\
  So that I can assist bots and use the E-Partner as my assistant

  \begin{description}
    \item[Scenario 1.3.1:] Starting the E-Partner\\
    Given the GOAL multi agent system is launched\\
    And there is an E-Partner in the map\\
    When a bot picks up the E-Partner\\
    Then the E-Partner should be started and all its features should be unlocked for the bot that has picked it up
    
    \item[Scenario 1.3.2:] Control\\
    Given the user holds the E-Partner\\
    When the user executes an action to move the block representing the E-Partner\\
    Then the block moves in the given direction
    
    \item[Scenario 1.3.3:] Communication (sending)\\
    Given the user holds the E-Partner\\
    When the user types in a message to send to another E-Partner\\
    And the user clicks to send the message\\
    Then the typed message is sent
    
    \item[Scenario 1.3.4:] Communication (receiving)\\
    Given the user holds the E-Partner\\
    When another bot or E-Partner sends a mesage to this E-Partner\\
    Then the message is shown to the user of the E-Partner
    
    \item[Scenario 1.3.5:] GPS functionality\\
    Given the user holds the E-Partner\\
    When the GPS functionality of the E-Partner is used\\
    Then the robot knows where it is on the map
  \end{description}
\end{description}
\section{Improvements}
    \begin{description}
    \item[Story 2.1:] Repast Stepper\\
    As a researcher into multi-agent systems\\
    I want to have a consistent simulation environment\\
    So that I can always reach the same final state if I were using deterministic agents.
    
        \begin{description}
        \item[Scenario 2.1.1:] Equal result\\
        Given the researcher has run a simulation using deterministic agents\\
        And the result was X\\
        When the researches re-runs the simulation\\
        Then the result should be X
        
        \item[Scenario 2.1.2:] Equal states\\
        Given the researcher is running a simulation on two seperate systems using deterministic agents\\
        When the researcher pauses the simulation at a specific tick\\
        Then the states on both computers should be equal
    \end{description}
    % Reclassified as an improvement, as it adds more realism to the
    % BW4T environment, which is a goal to be achieved.
  \item[Story 2.2:] Simulation (Handicaps)\\
  As a multi-agent systems researcher\\
  I want to create simulation conditions\\
  So that I can easily create specific scenarios
  
  \begin{description}
    \item[Scenario 2.2.1:] Bot store GUI\\
    Given the user has launched the scenario GUI\\
    When the user selects a bot from the list of bots in the scenario GUI\\
    Then the bot store GUI should be launched containing the settings for the selected bot
    
    \item[Scenario 2.2.2:] Gripper Handicap\\
    Given the bot store GUI has started before the simulation run\\
    When the user unchecks the ability for a bot to use its gripper\\
    Then during the simulation the bot should not be able to use its gripper

    \item[Scenario 2.2.3:] Colorblind Handicap\\
    Given the bot store GUI has started before the simulation run\\
    When the user unchecks the ability for a bot to see colors\\
    Then during the simulation the bot should not be able to differentiate between colors

    \item[Scenario 2.2.4:] Bot size\\
    Given the bot store GUI has started before the simulation run\\
    When the user changes the size of a bot\\
    Then during the simulation the bot should have that size and its restrictions

    \item[Scenario 2.2.5:] Bot speed\\
    Given the bot store GUI has started before the simulation run\\
    When the user changes the speed of a bot\\
    Then during the simulation the bot should have that speed

    \item[Scenario 2.2.6:] Physical aspects\\
    Given the bot store GUI has started before the simulation run\\
    When the user checks the physical aspects of a bot\\
    Then when the simulation runs this bot can only continue its path as long as it does not collide with other bots who have the physical aspects checked as well
  \end{description}
\end{description}
\section{Know-how acquisition}
\begin{description}
\item[Story 3.1:] Repast\\
To look further into the possibilities of using Repast we have to do extra exploration work.
Repast is used throughout the BW4T codebase, but is essential for the simulation to work.
Right now Repast is mostly used to keep track of objects and their locations in the continuous space.
Furthermore, the ``moveTo'' method of the continuous space is indirectly used to move the robots (they are drawn by using the location on the grid), but the pathfinding isn't done by Repast.
In fact, Repast does not have a pathfinder.
In Repast agents are moved by using either the ``moveTo'', ``moveByDisplacement'' or ``moveByVector'' methods.
In a nutshell, Repast is currently used as a collection of all objects in the simulation space, and to map objects to a certain point in the simulation space.
The fact that Repast isn't needed that much at the moment, doesn't mean that we should get rid of it.
It offers some features such as the RandomCartesianAdder class which allows for adding objects at a random location in a space, and which could therefore be used to generate random maps.
In addition it has support for getting specific objects or agents from neighbourhood grid spaces.
Therefore we should further explore the possibilities of Repast in improving our system.

\item[Story 3.2:] Existing code analysis\\
The code we have received to work with was not written by us and therefore requires our time to analyse what is already in the code and what should be changed or left out.
We know that the current version of the source code is unstructured, difficult to work with and uses an enormous hashmap.
Before we can refactor the current code we should first look into the code architecture and understand it.
\end{description}
\end{document}

