\documentclass{article}
\usepackage{geometry}

\geometry{verbose,a4paper,tmargin=2cm,bmargin=2cm,lmargin=2cm,rmargin=2cm}


\begin{document}

\section*{Collisions}
\subsection*{Features}
With the addition of collisions a few new features are available in BW4T. In this section list of these features will be presented, along with a short description of said feature.

\begin{description}
	\item[Feature: Collisions] \hfill \\
		It is now possible for bots to collide in each other. This option can be toggled on and off.
	\item[Percept: bumped] \hfill \\
		When a collision occurs a bumped percept is sent to the bot who caused the collision. The bumped percept contains the name of the bot being bumped into.
	\item[Action: navigateObstacles] \hfill \\
		When a collision the navigateObstacles/0 action can be used to request a new path from the path planner, taking blocked tiles into account.
	\item[Feature: Visualize Paths]
		The paths being traversed by the bots can be made visible on the server display. 
	\item[Feature: Improved Pathfinding]
		There are two pathfinders, one that uses the map zones as navigation points, and the new one which uses the grid points. 
\end{description}
		
\subsection*{Justification}
BW4T3 introduces the ability to collide into other bots on the map. Before version 3 there were no collision detection and handling methods, due to this bots were free to move through each other as they traversed the map. Before collisions could be enabled a few key issues had to be solved. In this section we these issues will be discussed and the reasoning behind specific design decisions explained. 

The main issue faced when planning the implementation of collision was that the path planner inherently could not handle collisions. In fact, the path planner as it is, is the main reason there are collisions. Currently all paths go through the center of each zone. Thus when traversing from A to C, all bots on that route will move through the center of B, thus creating a bottleneck. Furthermore, as the path planner only used the center of each zone, collisions could not be avoided if they were in the way to the center of a zone.
Therefore it was decided that a new path planner had to be implemented. This new path planner would not use the center of the map zones as navigation points, rather the points on the grid. To clarify, the map seen when the server running displays the map zones. These can be rooms, corridors, dropzones, etc. All objects (e.g. zones) present on the map are located on an `invisible' grid. The new path planner uses the points on this grid as its vertices, with the points on the north, south, east and west as neighbouring vertices, connected by an edge with length 1. 
While in theory vertical neighbours could be supported, they were not added as they are infinitesimally many, and would complicate collision detection. 

With the path planner created the next issue was detecting if a bot was going to collide into another bot or not. The original specifications called for a bumped percept to be called after a bot collided into another bot. Since implementing this would take as much effort as detecting a collision before it happened it was decided to detect collisions before they actually happen. In a way this is more realistic, as generally preventing a collision is the preferable solution.

When a collision is detected the `navigateObstacles' action can be used to plan a path around the obstacle. This action must be called seperately. The action is not automatically called when an obstacle is detected, as it would remove the possibility for the agents to coordinate a plan to go around an obstacle. (Especially if two agents are blocking each others path). Note: When a collision occurs the agent can also use the goTo actions to go to a new location provided the path is free. 

During the development of the collision features debugging proved quite complicated as there was no way to visually see the path generated. The solution was to draw the path on the map. This debugging tool proved quite handy during simulations, as it could be used to see how to bot reacted when a collision occured. While it may not have any scientific value as it is purely visual, it has been included in BW4T3. It could be a helpful debugging aide, especially for 1st year students doing following the AI course, as it can be used to debug and visualize the actions of the robots. 

A key improvement in BW4T3 was the complete and absolute seperation of the client and server. In accordance with this it is possible to turn collision detection on/off  by setting the appropiate option in the Scenario Editor. However, it is also possible to change this setting on the server (and thus modifying the scenario loaded by the client). While this is in stride with the decision to fully seperate the server and the client, it was decided to include the option on the server to make it easier to test environments with collisions enabled. To have to change the scenario and re-reload it on the server is extremely cumbersome. By simply checking a box collisions and be enabled, with the reverse true as well. 

\subsection*{Current Concerns}

At the moment there is an issue that prevents the startup of bots on top of each other when collisions are enabled. Due to the complexity of writing a procedure that makes sure every bot spawns on an unoccupied location, it had been decided that for all bots collisions will be disabled as long as, after they have spawned, they share a grid point with another bot. 
However, when using GOAL, somewhere during the initialiazation of Repast one of the navigating robots is presumably being cloned. But this happens after the robots are initially loaded into the context. Due to this, when the NavigatingRobot requests its location a null pointer is returned. This only happens when one robot is stepped before the other, with collisions enabled and two bots on top of each other. Despite meticulously searching for the cause it could not be located. However, a simple workaround exists. To prevent this error from occuring one must, after initializing the environment,run the server for at least one step.


\end{document}
